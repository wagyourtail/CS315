Script started on Tue 25 Oct 2022 04:16:38 PM MST
[?1034hsh-4.2$ car[Kt grayw7_hw3
grayw7_hw3.c             grayw7_hw3log.txt        grayw7_hw3_post_order.c  
sh-4.2$ cat grayw7_hw3.c
#include <stdio.h>
#include <malloc.h>
#include <stdbool.h>

struct BinaryTree {
    void* val;
    struct BinaryTree* left;
    struct BinaryTree* right;
};

typedef struct BinaryTree BinaryTree;

typedef BinaryTree* BinaryTreeHead;

bool btInsert(BinaryTreeHead* this, void* val, int(* cmp)(void*, void*));
bool btContains(BinaryTreeHead* this, void* val, int(* cmp)(void*, void*));
void btPreOrderTraverse(BinaryTreeHead* this, void(* visitor)(void*));
void btInOrderTraverse(BinaryTreeHead* this, void(* visitor)(void*));

struct ListNode {
    void* val;
    struct ListNode* next;
};

typedef struct ListNode* Stack;

void stackPush(Stack* this, void* val);
void* stackPop(Stack* this);
bool stackIsEmpty(Stack* this);

int charCmp(const char* a, const char* b);
void printChar(const char* c);

int main() {
    BinaryTreeHead head = {NULL};
    do {
        printf("Enter Choice - (I)nsert, (F)ind, (Q)uit: ");
        char choice;
        scanf(" %c", &choice);
        switch (choice) {
            case 'i':
            case 'I': {
                printf("Enter character to insert: ");
                char* val = malloc(sizeof(char));
                int success = scanf(" %c", val);
                if (success == 1) {
                    if (!btInsert(&head, val, (int (*)(void*, void*)) charCmp)) {
                        puts("\x1b[31mInsert failed\x1b[0m");
                    }
                    puts("");
                    puts("Preorder:");
                    btPreOrderTraverse(&head, (void (*)(void*)) printChar);
                    puts("");
                    puts("Inorder:");
                    btInOrderTraverse(&head, (void (*)(void*)) printChar);
                    puts("\n");
                } else {
                    // print err
                    puts("\x1b[31mscanf failed, insert failed\x1b[0m");
                    free(val);
                }
                break;
            }
            case 'f':
            case 'F': {
                printf("Enter character to find: ");
                char* val = malloc(sizeof(char));
                int success = scanf(" %c", val);
                if (success == 1) {
                    if (btContains(&head, val, (int (*)(void*, void*)) charCmp)) {
                        puts("\x1b[32mFound\x1b[0m");
                    } else {
                        puts("\x1b[31mNot Found\x1b[0m");
                    }
                } else {
                    // print err
                    puts("\x1b[31mscanf failed, find failed\x1b[0m");
                    free(val);
                }
                break;
            }
            case 'q':
            case 'Q': {
                return 0;
            }
            default: {
                puts("\x1b[31mInvalid choice\x1b[0m");
            }
        }

    } while (1);
}

int charCmp(const char* a, const char* b) {
    return *a - *b;
}

void printChar(const char* c) {
    printf("%c ", *c);
}

bool btInsert(BinaryTreeHead* this, void* val, int(* cmp)(void*, void*)) {
    if (*this == NULL) {
        *this = malloc(sizeof(BinaryTree));
        (*this)->val = val;
        (*this)->left = NULL;
        (*this)->right = NULL;
        return true;
    } else {
        BinaryTree* node = *this;
        while (true) {
            int cmpResult = cmp(val, node->val);
            if (cmpResult == 0) {
                return false;
            } else if (cmpResult < 0) {
                if (node->left == NULL) {
                    node->left = malloc(sizeof(BinaryTree));
                    node->left->val = val;
                    node->left->left = NULL;
                    node->left->right = NULL;
                    return true;
                } else {
                    node = node->left;
                }
            } else {
                if (node->right == NULL) {
                    node->right = malloc(sizeof(BinaryTree));
                    node->right->val = val;
                    node->right->left = NULL;
                    node->right->right = NULL;
                    return true;
                } else {
                    node = node->right;
                }
            }
        }
    }
}

bool btContains(BinaryTreeHead* this, void* val, int(* cmp)(void*, void*)) {
    if (*this == NULL) {
        return false;
    } else {
        BinaryTree* node = *this;
        while (true) {
            int cmpResult = cmp(val, node->val);
            if (cmpResult == 0) {
                return true;
            } else if (cmpResult < 0) {
                if (node->left == NULL) {
                    return false;
                } else {
                    node = node->left;
                }
            } else {
                if (node->right == NULL) {
                    return false;
                } else {
                    node = node->right;
                }
            }
        }
    }
}

void btPreOrderTraverse(BinaryTreeHead* this, void(* visitor)(void*)) {
    if (*this == NULL) {
        return;
    } else {
        Stack stack = {NULL};
        BinaryTree* node = *this;
        while (true) {
            visitor(node->val);
            if (node->left != NULL) {
                stackPush(&stack, node);
                node = node->left;
            } else if (node->right != NULL) {
                node = node->right;
            } else if (!stackIsEmpty(&stack)) {
                node = stackPop(&stack);
                node = node->right;
                while (node == NULL && !stackIsEmpty(&stack)) {
                    node = stackPop(&stack);
                    node = node->right;
                }
                if (node == NULL) {
                    return;
                }
            } else {
                return;
            }
        }
    }
}

void btInOrderTraverse(BinaryTreeHead* this, void(* visitor)(void*)) {
    if (*this == NULL) {
        return;
    } else {
        Stack stack = {NULL};
        BinaryTree* node = *this;
        while (true) {
            if (node->left != NULL) {
                stackPush(&stack, node);
                node = node->left;
            } else {
                visitor(node->val);
                if (node->right != NULL) {
                    node = node->right;
                } else if (!stackIsEmpty(&stack)) {
                    node = stackPop(&stack);
                    visitor(node->val);
                    node = node->right;
                    while (node == NULL && !stackIsEmpty(&stack)) {
                        node = stackPop(&stack);
                        visitor(node->val);
                        node = node->right;
                    }
                    if (node == NULL) {
                        return;
                    }
                } else {
                    return;
                }
            }
        }
    }
}

void stackPush(Stack* this, void* val) {
    struct ListNode* item = malloc(sizeof(struct ListNode));
    item->val = val;
    item->next = *this;
    *this = item;
}

void* stackPop(Stack* this) {
    if (*this == NULL) {
        return NULL;
    } else {
        struct ListNode* item = *this;
        *this = item->next;
        void* val = item->val;
        free(item);
        return val;
    }
}

bool stackIsEmpty(Stack* this) {
    return *this == NULL;
}sh-4.2$ gcc grayw7_hw3.c -o grayw7_hw3.out
sh-4.2$ grat[Kyw[K[K[K[K[K./grayw7_hw3.out 
Enter Choice - (I)nsert, (F)ind, (Q)uit: i
Enter character to insert: m

Preorder:
m 
Inorder:
m 

Enter Choice - (I)nsert, (F)ind, (Q)uit: i
Enter character to insert: d

Preorder:
m d 
Inorder:
d m 

Enter Choice - (I)nsert, (F)ind, (Q)uit: i
Enter character to insert: g

Preorder:
m d g 
Inorder:
d g m 

Enter Choice - (I)nsert, (F)ind, (Q)uit: i
Enter character to insert: r

Preorder:
m d g r 
Inorder:
d g m r 

Enter Choice - (I)nsert, (F)ind, (Q)uit: i
Enter character to insert: p

Preorder:
m d g r p 
Inorder:
d g m p r 

Enter Choice - (I)nsert, (F)ind, (Q)uit: i
Enter character to insert: b

Preorder:
m d b g r p 
Inorder:
b d g m p r 

Enter Choice - (I)nsert, (F)ind, (Q)uit: i
Enter character to insert: x

Preorder:
m d b g r p x 
Inorder:
b d g m p r x 

Enter Choice - (I)nsert, (F)ind, (Q)uit: f
Enter character to find: b
[32mFound[0m
Enter Choice - (I)nsert, (F)ind, (Q)uit: f
Enter character to find: p
[32mFound[0m
Enter Choice - (I)nsert, (F)ind, (Q)uit: f
Enter character to find: z
[31mNot Found[0m
Enter Choice - (I)nsert, (F)ind, (Q)uit: f
Enter character to find: e
[31mNot Found[0m
Enter Choice - (I)nsert, (F)ind, (Q)uit: q
sh-4.2$ exit
exit

Script done on Tue 25 Oct 2022 04:18:27 PM MST
